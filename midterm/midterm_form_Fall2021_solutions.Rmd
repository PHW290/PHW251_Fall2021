---
title: "PHW251 Midterm Exam (Fall 2021)"
date: "October 2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(lubridate)
```


\begin{Form}
    \TextField[width=20em]{Enter your name:} \par
\end{Form}



# Instructions

Download this PDF form to your computer and then open it with Adobe Reader or Adobe Acrobat Pro to fill it in. **Do not complete the form on your internet browser.**  For the short answer questions, you can either type information directly into each field, or copy and paste text from another program (like RStudio). You can save your responses and re-open this PDF later to modify or enter additional information. 

Submit your completed exam to Gradescope. Submit your R code file to the ungraded bCourses assignment called "Midterm Code"; we will only examine your code file to assign partial credit in Section 2 of the exam.

## Contents

- SECTION 1 - Multiple Choice - 10 pts
- SECTION 2 - Short Answer - 16 pts
- EXTRA CREDIT - 2 pts

# SECTION 1 - Multiple Choice

**[1 pt each, 10 total]** Each multiple choice question has only one correct answer. Type the letter corresponding to the correct answer in the box.

\newpage

## Question 1

Which of the following will return a value of `TRUE`?

`x <- 5`  
`y <- 25`

A.  `x != y` &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**
B.  `x*x = y`
C.  `x^2 > y`
D.  `y < x`

```{r, echo=T}
x <- 5
y <- 25

x != y #TRUE
#x*x = y #ERROR (= does assignment not comparison. x*x == y would return TRUE)
x^2>y #FALSE
y<x #FALSE
```



\newpage

## Question 2

With the lubridate package installed, you have the following character string:

`y_date <- "July 31, 2020"`

Which code would correctly yield a result five months prior to this date?

A.  `mdy(my_date) - months(5)`
B.  `mdy(my_date) %m-% months(5)` &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**
C.  `as_date(my_date) %m-% months(5)`
D.  `as_date(my_date) - months(5)`

```{r, echo=T}
my_date <- "July 31, 2020"

mdy(my_date) - months(5) #NA
mdy(my_date) %m-% months(5) #"2020-02-29"
as_date(my_date) %m-% months(5) #NA
# to use as_date() here, you would have to provide a format as below
# as_date(my_date, format="%B %d, %Y")
as_date(my_date) - months(5) #NA
```

\newpage

## Question 3

Which of these statements about vectors and lists is **false**?

A.  All vectors are lists, but not all lists are vectors &nbsp;&nbsp;&nbsp;**CREDIT GIVEN**
B.  A single vector can contain both numeric and character values &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**
C.  A single list can contain both numeric and character values
D.  Vectors and lists can be indexed using `[ ]`

```{r, echo=T}
# A (we gave credit for this answer)
# https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/list 
# says "Almost all lists in R internally are Generic Vectors"
test_vector <- c("hi", 3, 9)
is.list(test_vector) # however this returns false. difference is subtle and too tricky

test_list <- list("hi", 3, 9)
typeof(test_list)

# B (correct answer)
str(test_vector) # these all become strings
str(test_list) # only "hi" is a string; numbers remain numeric

# C
str(test_vector) # all strings

# D
test_vector[1] # works
test_list[1] # also works

```


## Question 4

Which code will create a vector with the following contents?

`2, 4, 6, 8, 10`

A.  `seq(2,10,by=2)` &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**
B.  `2:10`
C.  `seq(2,10,length.out=4)`
D.  `even(2,10)`

```{r, echo=T}
seq(2,10,by=2) #2  4  6  8 10 - CORRECT
2:10 #2  3  4  5  6  7  8  9 10
seq(2,10,length.out=4) #2.000000  4.666667  7.333333 10.000000
#even(2,10) #Error: could not find function "even"
```


\newpage

## Question 5

Which of the code blocks below creates the following plot?

```{r, echo=T}
mpg %>%
  select(displ, hwy) %>%
  ggplot(mapping = aes(x = hwy, y = displ)) + 
  geom_point() + 
  geom_smooth()
```


A.  `ggplot(data = mpg, mapping = aes(x = hwy, y = displ)), geom_point(), geom_smooth()`
B.  `ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +`  
&nbsp;&nbsp;&nbsp;`geom_point() +`  
&nbsp;&nbsp;&nbsp;`geom_smooth()`
C.  `mpg %>%` &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**  
&nbsp;&nbsp;&nbsp;`select(displ, hwy) %>%`   
&nbsp;&nbsp;&nbsp;`ggplot(mapping = aes(x = hwy, y = displ)) +`  
&nbsp;&nbsp;&nbsp;`geom_point() +`  
&nbsp;&nbsp;&nbsp;`geom_smooth()` 
D.  `ggplot(data = mpg, mapping = aes(x = hwy, y = displ)) %>%`  
&nbsp;&nbsp;&nbsp;`geom_point() %>%`  
&nbsp;&nbsp;&nbsp;`geom_smooth()`


\newpage

## Question 6

For the list that is generated by this code:

`multi_list <- list("Numbers" = seq(3,21,by=3),`  
&nbsp;&nbsp;&nbsp;`"Matrix" = matrix(c(-3,9,6,12,3,21), nrow = 2),`  
&nbsp;&nbsp;&nbsp;`"Words"=list("one","two","three"))`

Which of the following will **not** return a single value of 3? 

A.  `multi_list[["Numbers"]][1]`
B.  `multi_list[[2]][1,3]`
C.  `length(multi_list[["Words"]])`
D.  `multi_list["Numbers"][1]` &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**

```{r, echo=T}
multi_list<- list("Numbers" = seq(3,21,by=3), 
                  "Matrix" = matrix(c(-3,9,6,12,3,21), nrow = 2),
                  "Words"=list("one","two","three"))

 multi_list[["Numbers"]][1] #3
 multi_list[[2]][1,3] #3
 length(multi_list[["Words"]]) #3
 multi_list["Numbers"][1] #3  6  9 12 15 18 21 - CORRECT
```

\newpage

## Question 7

Data frames and tibbles are two options for storing tabular data in R. Which of the following is false? 

A.  When you print a tibble, the output will include the data type for each column
B.  Tibbles have more flexibility than data frames for naming columns (i.e. allowing spaces and symbols)
C.  Tibbles do not always have row names, whereas data frames do
D.  None of the answers above are false  &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**

```{r, echo=T}
test_tib <- as_tibble(iris)
test_df <- data.frame(iris)


test_tib # A: data type included

test_tib <- test_tib %>% rename("Sepal Length!!" = Sepal.Length)
names(test_tib) # B: spaces and symbols allowed

# C:
#  "All data frames have a row names attribute" 
#  https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/row.names
# "tibble() ... never creates row names." https://r4ds.had.co.nz/tibbles.html 
```

\newpage

## Question 8

Using the df below, which of the following will return a **vector** of the values in the cases column?

```{r}
df <- data.frame(
  state=c("CA","CA","AZ","AZ"),
  year=c(2019,2020,2019,2020),
  cases=c(34,23,89,27)
)
df
```

A.  `df$cases`  &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**
B.  `df[3]`
C.  `df[[cases]]`
D.  `df["cases"]`

```{r, echo=T}
df$cases #vector
df[3] #df/tibble
#df[[cases]] #error
df["cases"] #df/tibble
```


\newpage

## Question 9

Using the df below, which of the following will **not** return this subset data frame?

Original df:
```{r}
df
```

Subset data frame:
```{r}
subset(df,year==2020)
```

A.  `df[which(df$year==2020),]`
B.  `df[c(2,4)]`  &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**
C.  `df[df$year==2020,]`
D.  `subset(df,year==2020)`

```{r, echo=T}
 df[which(df$year==2020),]
 # df[c(2,4)] #CORRECT (returns error)
 df[df$year==2020,]
 subset(df,year==2020)
```


\newpage

## Question 10

There is a need to calculate the volume of a rectangular shipping container (length &#215; width &#215; height). If the volume is less than or equal to 1000 cubic feet, the code should print "too small", if it is greater than or equal to 2000 cubic feet it should print "too big", and if it is between 1000-2000 cubic feet it should print "just right".

Which block of code will print the correct value when

```{r, echo=TRUE}
l <- 12 # Length
w <- 5 # Width
h <- 6 # Height
```

A.  `if(volume >= 2000) {`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("too big")`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else if (volume <= 1000){`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("too small")`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else {`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("just right")}`  
B.  `volume <- l*w*h`  
`if(volume >= 2000) {`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("too big")`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else if (volume < 2000){`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("just right")`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else {`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("too small")}`  
C.  `volume <- l*w*h`  &nbsp;&nbsp;&nbsp;**CORRECT ANSWER**  
`if(volume >= 2000) {`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("too big")`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else if (volume <= 1000){`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("too small")`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else {`  
&nbsp;&nbsp;&nbsp;&nbsp;`print("just right")}`  
D.  `volume <- l*w*h`  
`if(volume >= 2000) {`  
&nbsp;&nbsp;&nbsp;&nbsp;`output <- "too big"`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else if (volume <= 1000){`  
&nbsp;&nbsp;&nbsp;&nbsp;`output <- "too small"`  
&nbsp;&nbsp;&nbsp;&nbsp;`} else {`  
&nbsp;&nbsp;&nbsp;&nbsp;`output <- "just right"}`  

```{r, echo=T}
# A: volume never calculated
# if(volume >= 2000) {
#     print("too big")
#     } else if (volume <= 1000){
#     print("too small")
#     } else {
#     print("just right")
#     }

# B: volume is correctly calculated as 360 but logic is incorrect
# (prints "just right" when it should be "too small")
# volume <- l*w*h
# 
# if(volume >= 2000) {
#     print("too big")
#     } else if (volume < 2000){
#     print("just right")
#     } else {
#     print("too small")
#     }

# C: correct answer
volume <- l*w*h
  
if(volume >= 2000) {
    print("too big")
    } else if (volume <= 1000){
    print("too small")
    } else {
    print("just right")
    }

# D: logic is correct but the value is never printed
# volume <- l*w*h
#   
# if(volume >= 2000) {
#     output <- "too big"
#     } else if (volume <= 1000){
#     output <- "too small"
#     } else {
#     output <- "just right"
#     }
```


\newpage

# SECTION 2 - Short Answer

**[16 points total]**

For all questions below, use the `inpatient_payer_ca.csv` file that is saved on DataHub/GitHub at `PHW251_Fall2021/midterm/inpatient_payer_ca.csv`. This is a real dataset from the California Health and Human Services Open Data Portal, but has been altered slightly for the purpose of this exam. The dataset contains counts of inpatient stays by expected payer source at California medical facilities. 

All questions below should be answered using R. In addition to turning in this PDF on Gradescope, Please submit your code via bCourses; your code will only be used to evaluate for partial credit on problems that are missed.

The file includes the following columns:

- Year 
- OSHPD Facility Number
- Facility Name
- County Name
- Expected Payer
- Count: count of inpatient stays expected per payer
- Total Inpatient Stays: total count of inpatient stays per facility per year

\newpage

## Question 11

### Part A

Import the csv data file.

What are the data types of each column when you read the data into R (numeric, factor, logical, character, etc)? **[1 pt]**

- Year: num
- OSHPD Facility Number: chr
- Facility Name: chr
- County Name: chr
- Expected Payer: chr
- Count: num
- Total Inpatient Stays: num

```{r, echo=T}
payer <- read_csv("inpatient_payer_ca.csv")

str(payer)
```

\newpage

### Part B

The “OSHPD Facility Number” column is reading in as character which is causing some ID’s to have leading zeros, creating inconsistencies in the data. Force it to read in as numeric to drop the leading 0.

Paste the argument used at import below. **[1 pt]**

```{r, echo=T}
# this is not the only method
payer <- read_csv(
  "inpatient_payer_ca.csv",
  col_types = "nncccnn"      #this is the argument we were looking for
)

str(payer)
```

\newpage

### Part C

Notice the column names are not reading in a very user-friendly way. Rename all columns to align with best practices for naming (lowercase with underscores in place of spaces). 

Paste the new column names and the line(s) of code you used to change them below. **[1 pt]**

Column names:

"year" "oshpd_facility_number" "facility_name" "county_name" "expected_payer" "count" "total_inpatient_stays"

Code:

```{r, echo=T}
payer <- payer %>%
  rename_with(~ tolower(gsub(" ","_",.x,fixed=TRUE))) 

# another method using stringr
colnames(payer) <- str_to_lower(gsub(" ", "_", colnames(payer)))

names(payer)
```


\newpage

## Question 12

There are some facilities with duplicate records for a year and payer type; in some cases the counts on these records differ. Retain only one record per year, facility id, and payer type; for instances where there are records with different counts, retain the record with the highest number.

How many rows remain? **[1 pt]**
```{r, echo=T}
payer12 <- payer %>%
  arrange(year,oshpd_facility_number, expected_payer, desc(count)) %>%
  distinct(year,oshpd_facility_number, expected_payer, .keep_all=TRUE)

count(payer12)
# 21899 is cut down to 21632 rows
```

What is the count of Private Coverage inpatient stays at Kern Medical Center for 2013? **[1 pt]**
```{r, echo=T}
# search for the exact name of Kern Medical Center
names <- unique(payer12$facility_name)
names[str_detect(names, "KERN")]
# filter desired row
filter(payer12, 
       facility_name == "KERN MEDICAL CENTER", 
       year == 2013, 
       expected_payer == "Private Coverage")
# count is 733
```

\newpage

## Question 13

**Questions 13 through 17 are designed to build off each other.**

Limit the dataset from question 12 to only contain rows where Medi-Cal is the expected payer and year is between 2010 and 2015.

How many records are in the subsetted dataset? **[1 pt]**

```{r, echo=T}
payer13 <- payer12 %>%
    filter(expected_payer=="Medi-Cal" & year %in% 2010:2015) 

# another filter method to accomplish the same thing
payer13 <- payer12 %>%
    filter(expected_payer == "Medi-Cal", year <= 2015, year >= 2010)

count(payer13) #2557
```

\newpage

## Question 14

Create a new column called `pct_medi_cal` that calculates the percent of total inpatient stays that were covered by Medi-Cal. Display the percentage as multiplied by 100 and rounded to 1 decimal (for example, 35.1% as 35.1). 

What is the value of pct_medi_cal for Eden Medical Center in 2015? **[1 pt]**

```{r, echo=T}
payer14 <- payer13 %>%
  mutate(pct_medi_cal = round(100*count/total_inpatient_stays,1)) 

payer14 %>% filter(facility_name=="EDEN MEDICAL CENTER" & year==2015) %>%
  pull(pct_medi_cal) #28.4
```

\newpage

## Question 15

Order the table to display rows by most recent year and percent of inpatient visits that were covered by Medi-Cal. 

Enter the Facility Name(s) that shows up at the top of the dataset with the highest proportion of inpatient visits covered by Medi-Cal in 2015. If there are multiple facilities with the same highest value, please list all facilities.  **[1 pt]**

```{r, echo=T}
payer15 <- payer14 %>%
  arrange(desc(year),desc(pct_medi_cal))

head(select(payer15, facility_name, pct_medi_cal))

# STAR VIEW ADOLESCENT - P H F
# CRESTWOOD PSYCHIATRIC HEALTH FACILITY-CARMICHAEL	
# CRESTWOOD PSYCHIATRIC HEALTH FACILITY-SACRAMENTO
```


\newpage

## Question 16

Create another new column called `above_below_avg`  that categorizes `pct_medi_cal`  based on average of percent paid by Medi-Cal among facilities from 2010-2015. If a facility has  percent equal to or above average, categorize it as "above"; otherwise, categorize as "below".

What is the average (mean) percentage of inpatient stays covered by Medi-Cal for all facilities from 2010-2015? **[1 pt]**

```{r, echo=T}
summary(payer15$pct_medi_cal) #summary includes the mean (27.38)
mean(payer15$pct_medi_cal) #or calculate the average specifically

payer16 <- payer15 %>%
  mutate(above_below_avg = if_else(pct_medi_cal >= 27.38,"above","below"))
```

What is the value of `above_below_avg` for Woodland Memorial Hospital for 2010? **[1 pt]**

```{r, echo=T}
payer16 %>% filter(year==2010 & facility_name=="WOODLAND MEMORIAL HOSPITAL") %>%
    pull(above_below_avg) #below
```

\newpage

## Question 17

There is interest in knowing specifically about payers for Kaiser facilities. Create a new variable to flag observations for Kaiser facilities. Restrict the dataset to only include records for Kaiser facilities, Medi-Cal, Counts > 0, and the year 2015.

How many records remain? **[1 pt]**

```{r, echo=T}
payer17 <- payer16 %>%
  mutate(kaiser_flag = if_else(str_detect(facility_name,"KAISER")==TRUE,
                               "kaiser",
                               "not kaiser")) %>%
  filter(kaiser_flag=="kaiser" & count>0 & year==2015)

count(payer17) #32
```


What Kaiser facility has the highest percent of Medi-Cal covered inpatient stays? **[1 pt]**

```{r, echo=T}
payer17 %>% arrange(desc(pct_medi_cal)) %>% head(1) %>% pull(facility_name)
#	KAISER FND HOSP - SOUTH SACRAMENTO
```

\newpage

## Question 18

Question 18 & 19 utilize the dataset you imported in #11. To start, create a new subset data frame that includes the following columns: Year, Facility Name, County Name, Expected Payer, Count, and Total Inpatient Stays. Only keep records for expected payer of Medi-Cal and the year 2015. 

Create a new data frame that contains summary values for each county for 2015 including total number of Medi-Cal inpatient stays per county and total number of inpatient stays per county. 

Re-order the table to display the county with the highest number of Medi-Cal covered inpatient stays at the top of the table. What county has the highest total number of Medi-Cal covered inpatient stays in 2015? **[1 pt]**

```{r, echo=T}
payer18 <- payer %>%
  filter(year==2015 & expected_payer=="Medi-Cal") %>%
  select(facility_name, county_name, expected_payer, count, total_inpatient_stays) %>%
  group_by(county_name) %>%
  summarise(medical_total = sum(count),
            all_total = sum(total_inpatient_stays)) %>%
  arrange(desc(medical_total))

head(payer18) #LOS ANGELES
```

\newpage

## Question 19

Building on to the data frame created in #18, create a new column called `coverage_category` indicating the level of Medi-Cal coverage in each county as determined by the proportion of total inpatient stays that are covered by Medi-Cal. The categories should be defined as:

- "High": > 66% of inpatient stays covered by Medi-Cal
- "Medium": > 33% of inpatient stays covered by Medi-Cal
- "Low": $\leq$ 33%  

Create a final table that summarizes the number of counties in each category (hint: this table should only have 3 rows).

How many counties are in the "low" coverage category? **[1 pt]**

```{r, echo=T}
payer19 <- payer18 %>%
  mutate(coverage_cat = case_when(
    medical_total/all_total > 0.66 ~ "High",
    medical_total/all_total > 0.33 ~ "Medium",
    TRUE ~ "Low"
  )) %>%
  group_by(coverage_cat) %>%
  count() 

payer19 #32
```

\newpage

## Question 20

Question 20 utilizes the dataset as it was first imported in question #11. 

Create a subset dataset with only records for 2015. Keep only the following columns: Facility Name, County Name, Expected Payer, and Count. Pivot the dataset to create columns for each of the expected payer types; these columns should each contain the counts of inpatient stays for each type. 

How many records are in the dataset after the pivot? **[1 pt]**

```{r, echo=T}
payer20 <- payer %>%
  filter(year==2015) %>%
  select(facility_name, county_name, expected_payer, count) %>%
  pivot_wider(names_from=expected_payer, values_from=count)

count(payer20) #449
```

Include the line of code used to perform the pivot. Make sure to include the function name as well as the arguments used. **[1 pt]**

```{r, echo=T}
# pivot_wider(names_from=expected_payer, values_from=count)
```


\newpage

# EXTRA CREDIT

**[2 points total]**

Complete questions #18 and #19 using only one dplyr call. In other words, start with the dataset imported in question #11, perform the necessary subsetting, grouping, and summarizing with the end goal of producing a table that displays the number of counties in each Medi-Cal coverage category. 

Please include sufficient code for the teaching team to be able to run your code, if needed. This means either including the import statement for the csv, or including the import statement as part of your dplyr call. 

Hint: Including more than one `group_by()` in a single call may also require the use of `ungroup()`. 

Paste the single dplyr call below. **[1 pt]**

```{r, echo=T}
payer_extra <- read_csv(
  "inpatient_payer_ca.csv",
  col_types = "nncccnn") %>%
  rename_with(~ tolower(gsub(" ","_",.x,fixed=TRUE))) %>%
  filter(year==2015 & expected_payer=="Medi-Cal") %>%
  select(facility_name, county_name, expected_payer, count, total_inpatient_stays) %>%
  group_by(county_name) %>%
  summarise(medical_total = sum(count),
            all_total = sum(total_inpatient_stays)) %>%
  mutate(coverage_cat = case_when(
    medical_total/all_total > 0.66 ~ "High",
    medical_total/all_total > 0.33 ~ "Medium",
    TRUE ~ "Low"
  )) %>%
  group_by(coverage_cat) %>%
  count()

payer_extra
identical(payer_extra, payer19) #show they are the same
```


\newpage

Include code that uses the `kable` package to print the final table for #19 in a print-friendly format (easy to read with meaningful column names).  **[1 pt]**

```{r, echo=T}
knitr::kable(payer_extra,col.names =c("Medi-Cal Coverage","Number of Counties"))
```








